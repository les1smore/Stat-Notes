# Fitting
from lifetimes import BetaGeoFitter

# instantiation of BG-NBD model
bgf = BetaGeoFitter(penalizer_coef = 0.0)

# fitting of BG-NBD model
bgf.fit(frequency = rfm_cal_holdout['frequency_cal'],
        recency = rfm_cal_holdout['recency_cal'],
        T = rfm_cal_holdout['T_cal'])

bgf.summary

# Assessment of model fit
# First is to compare the frequencies between our real calibration data and artificial data sampled from the distributions generated by the BG-NBD model
from lifetimes.plotting import plot_period_transactions

_ = plot_period_transactions(bgf)

# Prediction
# First we choose a sample customer
sample_customer = rfm_cal_holdout.iloc[20]

# Inspect this customer's frequency, recency and T both for the calibration and observation periods
sample_customer

# Calculate the conditional expected number of transactions in the given period
n_transactions_pred = bgf.predict(t = 26, # set it to 26 weeks (the length of the observation period)
                                  frequency = sample_customer['frequency_cal'],
                                  recency = sample_customer['recency_cal'],
                                  T = sample_customer['T_cal'])
n_transactions_pred

# Calculate the probability of alive customers
alive_prob = bgf.conditional_probability_alive(frequency = sample_customer['frequency_cal'],
                                               recency = sample_customer['recency_cal'],
                                               T = sample_customer['T_cal'])
alive_prob

# Compare the real and predicted number of transactions
# Get the real number of transactions in the observation period, which equals frequency_holdout + 1
rfm_cal_holdout['n_transactions_holdout_real'] = rfm_cal_holdout['frequency_holdout'] + 1

# Get the predicted number of transactions in the next 26 weeks (lenght of the observation period)
rfm_cal_holdout['n_transactions_holdout_pred'] = bgf.predict(t=26,
                                                             frequency=rfm_cal_holdout['frequency_cal'],
                                                             recency = rfm_cal_holdout['recency_cal'],
                                                             T = rfm_cal_holdout['T_cal'])
# Compare the real and predicted transactions
rfm_cal_holdout[['n_transactions_holdout_real', 'n_transactions_holdout_pred']].head()

#RMSE
from sklearn.metrics import mean_squared_error

RMSE = mean_squared_error(y_true = rfm_cal_holdout['n_transactions_holdout_real'],
                          y_pred = rfm_cal_holdout['n_transactions_holdout_pred'],
                          squared = False)
RMSE



